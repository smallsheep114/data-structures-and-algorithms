## 1.数据结构（初阶）--c语言

### 1.数据结构

实现一些项目，需要在内存中将数据存储起来

1. 数组
2. 链表
3. 树
4. ……

### 2.算法

1. 排序
2. 查找
3. 去重
4. ……
5. 推荐算法

### 3.算法效率（关注执行次数）

* 时间复杂度--运行快慢

  时间复杂度是**一个函数**，运行时间与运行环境有关，所以我们更加去**关注执行次数**

  如：F(N) = N*N + 2 *N +10，随着N的增大，后两项对结构的影响越小

  **看表达式中影响最大的一项**

  

  **大O渐进表示**法：O(n^2)--可以表示大概的运行结构次数

  **大O表示法**规则：

  1. 只取最高次项

  2. 忽略系数

  3. 用O(1)去代替所有运行次数为**常数次**的时间复杂度

  4. 时间复杂度做**悲观预期**，看**最坏的情况**

     算法分为最好情况，平均情况，最坏的情况

     例子：

     * 冒泡排序：次数N*(N-1)/2，O(N^2)
     * 二分查找：O(log2 N)
     * 递归  O(N)--**跟递归深度有关**
     * 斐波那契额数列 次数：2^0 +2 ^1+......2 ^n-1-X    O(2^n) 

     所以计算时间复杂度还是要去**画图**和**思考**
     
     

* 空间复杂度--运行所需要的额外空间（关注变量的个数）

  也是一个函数（也可用大O表示法），不关注程序占用了了多少byte，但是关注临时**占用额外存储空间大小的量度**--  **变量的个数**

  例子：

  * 递归实现阶层：O(N)--**每一次调用**都用建立**栈帧**，跟递归深度有关

  * **斐波那契数列**：O(N)--==空间是可以重复使用不累计的，时间是一去不复返==  即使出现了很多fib(2),fib(3)，但是调用的时候重复的fib占用同一块空间，所以最多调用了n块空间

    递归使用顺序的，先递归谁，再递归谁，并不是同时一起递归的

    

**摩尔定律**--空间18个月就要经历翻一番，但cpu的性能到了物理极限

所以现在越来越关注时间复杂度（相比于空间复杂度）

### 4.找不同--用异或^

按位异或，相同为0，相异为1

### 5.递归要建立栈帧

==所以递归实现n！的空间复杂度是O(N)，每个栈帧使用了常数个空间==

返回时会销毁

### 6.旋转数组的高效方法--三次逆置





